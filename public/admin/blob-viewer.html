<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Panel Admin - Vercel Blob Images - Customify</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: #f5f5f5;
      padding: 20px;
      color: #333;
    }
    
    .container {
      max-width: 1400px;
      margin: 0 auto;
      background: white;
      border-radius: 12px;
      padding: 30px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    
    h1 {
      margin-bottom: 30px;
      color: #1565C0;
      font-size: 28px;
    }
    
    .controls {
      display: flex;
      gap: 15px;
      margin-bottom: 30px;
      flex-wrap: wrap;
      align-items: center;
    }
    
    .control-group {
      display: flex;
      gap: 10px;
      align-items: center;
    }
    
    select, input, button {
      padding: 10px 15px;
      border: 1px solid #ddd;
      border-radius: 6px;
      font-size: 14px;
    }
    
    select {
      cursor: pointer;
    }
    
    button {
      background: #1565C0;
      color: white;
      border: none;
      cursor: pointer;
      font-weight: 600;
      transition: background 0.2s;
    }
    
    button:hover {
      background: #0d47a1;
    }
    
    button.danger {
      background: #f44336;
    }
    
    button.danger:hover {
      background: #d32f2f;
    }
    
    button.success {
      background: #4CAF50;
    }
    
    button.success:hover {
      background: #45a049;
    }
    
    .stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 15px;
      margin-bottom: 30px;
    }
    
    .stat-card {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 15px;
      border-radius: 8px;
      text-align: center;
    }
    
    .stat-card.temp {
      background: linear-gradient(135deg, #FF9800 0%, #F57C00 100%);
    }
    
    .stat-card.orders {
      background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
    }
    
    .stat-card.watermarked {
      background: linear-gradient(135deg, #9C27B0 0%, #7B1FA2 100%);
    }
    
    .stat-card.koszyki {
      background: linear-gradient(135deg, #9C27B0 0%, #7B1FA2 100%);
    }
    
    .stat-card.original {
      background: linear-gradient(135deg, #2196F3 0%, #1976D2 100%);
    }
    
    .stat-card.wygenerowane {
      background: linear-gradient(135deg, #00BCD4 0%, #0097A7 100%);
    }
    
    .stat-value {
      font-size: 28px;
      font-weight: bold;
      margin-bottom: 5px;
    }
    
    .stat-label {
      font-size: 12px;
      opacity: 0.9;
    }
    
    .gallery {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 20px;
      margin-top: 20px;
    }
    
    .image-card {
      border: 2px solid #e0e0e0;
      border-radius: 8px;
      overflow: hidden;
      transition: transform 0.2s, box-shadow 0.2s;
      background: white;
    }
    
    .image-card:hover {
      transform: translateY(-4px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }
    
    .image-card.selected {
      border-color: #1565C0;
      box-shadow: 0 0 0 3px rgba(21, 101, 192, 0.2);
    }
    
    .image-card img {
      width: 100%;
      height: 200px;
      object-fit: cover;
      display: block;
    }
    
    .image-info {
      padding: 10px;
      font-size: 12px;
    }
    
    .image-info .category {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 10px;
      font-weight: 600;
      margin-bottom: 5px;
    }
    
    .category.upload {
      background: #FFE0B2;
      color: #E65100;
    }
    
    .category.orders {
      background: #C8E6C9;
      color: #2E7D32;
    }
    
    .category.watermarked {
      background: #E1BEE7;
      color: #6A1B9A;
    }
    
    .category.koszyki {
      background: #E1BEE7;
      color: #6A1B9A;
    }
    
    .category.wygenerowane {
      background: #B3E5FC;
      color: #0277BD;
    }
    
    .category.statystyki {
      background: #E1BEE7;
      color: #7B1FA2;
    }
    
    .product-type {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 10px;
      font-weight: 600;
      margin-bottom: 4px;
      background: #E8F5E9;
      color: #2E7D32;
    }
    
    .image-info .filename {
      word-break: break-all;
      color: #666;
      margin-bottom: 5px;
    }
    
    .image-info .date {
      color: #999;
      font-size: 10px;
    }
    
    .checkbox {
      position: absolute;
      top: 10px;
      right: 10px;
      width: 20px;
      height: 20px;
      cursor: pointer;
      z-index: 10; /* musi byƒá NAD obrazkiem */
      background: rgba(255,255,255,0.9);
      border-radius: 4px;
      padding: 2px;
      accent-color: #1565C0;
    }
    
    .image-card {
      position: relative;
    }
    
    .loading {
      text-align: center;
      padding: 40px;
      color: #666;
    }
    
    .error {
      background: #ffebee;
      color: #c62828;
      padding: 15px;
      border-radius: 6px;
      margin-bottom: 20px;
    }
    
    .mass-actions {
      background: #f5f5f5;
      padding: 15px;
      border-radius: 6px;
      margin-bottom: 20px;
      display: flex;
      gap: 10px;
      align-items: center;
    }
    
    .mass-actions.hidden {
      display: none;
    }
  </style>
</head>
<body>
  <div class="container">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
      <h1 style="margin: 0;">üñºÔ∏è Panel Admin - Vercel Blob Images</h1>
      <button onclick="logout()" style="padding: 8px 16px; background: #f44336; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; display: none;" id="logoutBtn">Wyloguj</button>
    </div>
    
    <div id="errorContainer"></div>
    
    <!-- Formularz logowania -->
    <div id="loginForm" style="display: none; max-width: 400px; margin: 50px auto; padding: 30px; background: white; border-radius: 12px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
      <h2 style="margin-bottom: 20px; color: #1565C0;">üîê Logowanie do panelu</h2>
      <div style="margin-bottom: 15px;">
        <label style="display: block; margin-bottom: 5px; font-weight: 600;">Token (ADMIN_STATS_TOKEN z Vercel):</label>
        <input type="password" id="passwordInput" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 6px; font-size: 14px;" placeholder="Wprowad≈∫ token z Vercel">
      </div>
      <button onclick="checkPassword()" style="width: 100%; padding: 12px; background: #1565C0; color: white; border: none; border-radius: 6px; font-weight: 600; cursor: pointer; font-size: 16px;">Zaloguj siƒô</button>
      <div id="passwordError" style="margin-top: 10px; color: #f44336; display: none;">‚ùå Nieprawid≈Çowy token</div>
    </div>
    
    <div id="mainContent" style="display: none;">
    <div class="controls">
      <div class="control-group">
        <label><strong>Kategoria:</strong></label>
        <select id="categoryFilter">
          <option value="all">Wszystkie</option>
          <option value="upload">Upload</option>
          <option value="orders">Orders</option>
          <option value="koszyki">Koszyki</option>
          <option value="wygenerowane">Wygenerowane</option>
          <option value="statystyki">Statystyki</option>
        </select>
      </div>
      <div class="control-group" id="productTypeFilterGroup" style="display: none;">
        <label><strong>Produkt:</strong></label>
        <select id="productTypeFilter">
          <option value="">Wszystkie produkty</option>
          <option value="caricature">Karykatura</option>
          <option value="king">Kr√≥l</option>
          <option value="queen">Kr√≥lowa</option>
          <option value="cats">Koty</option>
          <option value="phone">Telefon</option>
          <option value="boho">Boho</option>
          <option value="spotify">Spotify</option>
          <option value="etui">Etui</option>
          <option value="other">Inne</option>
        </select>
      </div>
      
      <div class="control-group">
        <label><strong>Data od:</strong></label>
        <input type="date" id="dateFrom" style="padding: 8px;">
      </div>
      
      <div class="control-group">
        <label><strong>Data do:</strong></label>
        <input type="date" id="dateTo" style="padding: 8px;">
      </div>
      
      <div class="control-group">
        <button onclick="setDateRange('today')" style="padding: 8px 12px; font-size: 12px;">Dzisiaj</button>
        <button onclick="setDateRange('week')" style="padding: 8px 12px; font-size: 12px;">Ostatni tydzie≈Ñ</button>
        <button onclick="clearDateRange()" style="padding: 8px 12px; font-size: 12px;">Wyczy≈õƒá</button>
      </div>
      
      <div class="control-group">
        <label><strong>Sortowanie:</strong></label>
        <select id="sortBy">
          <option value="date">Data</option>
          <option value="name">Nazwa</option>
        </select>
        <select id="sortOrder">
          <option value="desc">Najnowsze</option>
          <option value="asc">Najstarsze</option>
        </select>
      </div>
      
      <button onclick="loadImages()">üîÑ Od≈õwie≈º</button>
      <button class="success" onclick="selectAll()">‚úì Zaznacz wszystkie</button>
      <button class="danger" onclick="deleteSelected()" id="deleteBtn" disabled>üóëÔ∏è Usu≈Ñ zaznaczone (<span id="selectedCount">0</span>)</button>
      <button class="danger" onclick="runAutoCleanupOldFiles()" id="cleanupBtn" title="Usuwa pliki z customify/temp/ starsze ni≈º 14 dni (w turach, bez timeout√≥w)">üßπ Wyczy≈õƒá stare (14 dni)</button>
    </div>
    
    <div class="mass-actions hidden" id="massActions">
      <span id="selectedCountText">0 obrazk√≥w zaznaczonych</span>
    </div>
    
    <div class="mass-actions hidden" id="cleanupStatus" style="justify-content: space-between;">
      <span id="cleanupStatusText">Czyszczenie...</span>
      <button onclick="cancelAutoCleanup()" style="background:#666;">Przerwij</button>
    </div>
    
    <div class="stats" id="stats">
      <div class="stat-card">
        <div class="stat-value" id="statTotal">0</div>
        <div class="stat-label">Wszystkie</div>
      </div>
      <div class="stat-card temp">
        <div class="stat-value" id="statUpload">0</div>
        <div class="stat-label">Upload</div>
      </div>
      <div class="stat-card orders">
        <div class="stat-value" id="statOrders">0</div>
        <div class="stat-label">Orders</div>
      </div>
      <div class="stat-card watermarked">
        <div class="stat-value" id="statKoszyki">0</div>
        <div class="stat-label">Koszyki</div>
      </div>
      <div class="stat-card original">
        <div class="stat-value" id="statWygenerowane">0</div>
        <div class="stat-label">Wygenerowane</div>
      </div>
      <div class="stat-card" style="background: linear-gradient(135deg, #9C27B0 0%, #7B1FA2 100%);">
        <div class="stat-value" id="statStatystyki">0</div>
        <div class="stat-label">Statystyki</div>
      </div>
      <div class="stat-card" style="background: linear-gradient(135deg, #1565C0 0%, #0d47a1 100%);">
        <div class="stat-value" id="statFiltered">0</div>
        <div class="stat-label">W filtrze</div>
      </div>
    </div>
    
    <div id="loading" class="loading">≈Åadowanie obrazk√≥w...</div>
    <div id="gallery" class="gallery"></div>
    <div id="loadMoreIndicator" style="display: none; text-align: center; padding: 20px; color: #666;">
      <div style="display: inline-block; padding: 10px 20px; background: #f5f5f5; border-radius: 6px;">
        ‚è≥ ≈Åadowanie wiƒôcej obrazk√≥w...
      </div>
    </div>
    </div>
  </div>
  
  <script>
    const API_BASE = 'https://customify-s56o.vercel.app/api/admin';
    let AUTH_TOKEN = localStorage.getItem('customify_admin_token');
    let isLoggedIn = localStorage.getItem('blob_viewer_logged_in') === 'true';
    let currentCursor = null;
    let allImages = [];
    let selectedImages = new Set();
    
    // Sprawd≈∫ czy u≈ºytkownik jest zalogowany
    function checkLogin() {
      if (isLoggedIn && AUTH_TOKEN) {
        document.getElementById('loginForm').style.display = 'none';
        document.getElementById('mainContent').style.display = 'block';
        document.getElementById('logoutBtn').style.display = 'block';
        
        // Domy≈õlnie poka≈º ostatnie 5 dni (tylko je≈õli user nie ustawi≈Ç w≈Çasnych dat)
        setDefaultLastDaysIfEmpty(5);
        loadImages(true);
      } else {
        document.getElementById('loginForm').style.display = 'block';
        document.getElementById('mainContent').style.display = 'none';
        document.getElementById('logoutBtn').style.display = 'none';
      }
    }
    
    function logout() {
      if (confirm('Czy na pewno chcesz siƒô wylogowaƒá?')) {
        isLoggedIn = false;
        localStorage.removeItem('blob_viewer_logged_in');
        document.getElementById('passwordInput').value = '';
        checkLogin();
      }
    }
    
    async function checkPassword() {
      const passwordInput = document.getElementById('passwordInput');
      const passwordError = document.getElementById('passwordError');
      const password = passwordInput.value.trim();
      
      if (!password) {
        passwordError.textContent = '‚ùå Wprowad≈∫ token';
        passwordError.style.display = 'block';
        return;
      }
      
      // U≈ºyj wprowadzonego tokena jako ADMIN_STATS_TOKEN
      AUTH_TOKEN = password;
      localStorage.setItem('customify_admin_token', AUTH_TOKEN);
      
      // Sprawd≈∫ czy token dzia≈Ça - spr√≥buj za≈Çadowaƒá obrazki
      passwordError.style.display = 'none';
      passwordError.textContent = '‚è≥ Sprawdzanie tokena...';
      passwordError.style.color = '#1565C0';
      passwordError.style.display = 'block';
      
      try {
        // Test tokena - spr√≥buj pobraƒá listƒô obrazk√≥w
        const testResponse = await fetch(`${API_BASE}/list-blob-images?limit=1`, {
          headers: {
            'Authorization': `Bearer ${AUTH_TOKEN}`
          }
        });
        
        if (testResponse.ok) {
          // Token dzia≈Ça!
          isLoggedIn = true;
          localStorage.setItem('blob_viewer_logged_in', 'true');
          passwordError.style.display = 'none';
          checkLogin();
        } else if (testResponse.status === 401) {
          // Nieprawid≈Çowy token
          passwordError.textContent = '‚ùå Nieprawid≈Çowy token. Sprawd≈∫ czy u≈ºywasz ADMIN_STATS_TOKEN z Vercel.';
          passwordError.style.color = '#f44336';
          passwordError.style.display = 'block';
          passwordInput.value = '';
          passwordInput.focus();
          AUTH_TOKEN = null;
          localStorage.removeItem('customify_admin_token');
        } else {
          throw new Error(`HTTP ${testResponse.status}`);
        }
      } catch (error) {
        console.error('Error checking token:', error);
        passwordError.textContent = '‚ùå B≈ÇƒÖd po≈ÇƒÖczenia. Sprawd≈∫ po≈ÇƒÖczenie internetowe.';
        passwordError.style.color = '#f44336';
        passwordError.style.display = 'block';
        AUTH_TOKEN = null;
        localStorage.removeItem('customify_admin_token');
      }
    }
    
    // Enter w polu has≈Ça
    document.addEventListener('DOMContentLoaded', function() {
      const passwordInput = document.getElementById('passwordInput');
      if (passwordInput) {
        passwordInput.addEventListener('keypress', function(e) {
          if (e.key === 'Enter') {
            checkPassword();
          }
        });
      }
      checkLogin();
    });
    
    async function loadImages(reset = true) {
      if (!AUTH_TOKEN) {
        document.getElementById('errorContainer').innerHTML = '<div class="error">‚ùå Brak tokena autoryzacji</div>';
        return Promise.resolve();
      }
      
      if (reset) {
        allImages = [];
        currentCursor = null;
        selectedImages.clear();
        updateDeleteButton();
      }
      
      const loadingEl = document.getElementById('loading');
      const galleryEl = document.getElementById('gallery');
      const errorContainer = document.getElementById('errorContainer');
      
      loadingEl.style.display = 'block';
      errorContainer.innerHTML = '';
      
      const sortBy = document.getElementById('sortBy').value;
      const sortOrder = document.getElementById('sortOrder').value;
      
      // ‚ö†Ô∏è NIE FILTRUJ PO KATEGORII W API - pobierz WSZYSTKIE obrazy, filtrowanie po stronie klienta
      try {
        // Backend pobiera wszystkie pliki (bez limitu) i sortuje po stronie serwera
        const url = `${API_BASE}/list-blob-images?sortBy=${sortBy}&sortOrder=${sortOrder}${currentCursor ? '&cursor=' + encodeURIComponent(currentCursor) : ''}`;
        
        const response = await fetch(url, {
          headers: {
            'Authorization': `Bearer ${AUTH_TOKEN}`
          }
        });
        
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const data = await response.json();
        
        if (!data.success) {
          throw new Error(data.error || 'Unknown error');
        }
        
        // Dodaj nowe obrazki do listy (WSZYSTKIE kategorie)
        allImages = reset ? data.images : [...allImages, ...data.images];
        
        // Debug: sprawd≈∫ pierwsze obrazy i kategorie
        if (reset && allImages.length > 0) {
          console.log('üîç [LOAD] First 10 images with categories:', allImages.slice(0, 10).map(img => ({
            pathname: img.pathname,
            category: img.category,
            uploadedAt: img.uploadedAt,
            hasCategory: !!img.category
          })));
          
          // Sprawd≈∫ ile obrazk√≥w ma kategoriƒô "wygenerowane"
          const wygenerowaneCount = allImages.filter(img => img.category === 'wygenerowane').length;
          console.log(`üîç [LOAD] Images with category "wygenerowane": ${wygenerowaneCount} / ${allImages.length}`);
          
          // Poka≈º przyk≈Çadowe obrazy z temp/ kt√≥re powinny byƒá "wygenerowane"
          const tempImages = allImages.filter(img => img.pathname && img.pathname.includes('temp/'));
          console.log(`üîç [LOAD] Temp images (${tempImages.length}):`, tempImages.slice(0, 5).map(img => ({
            pathname: img.pathname,
            category: img.category
          })));
        }
        currentCursor = data.cursor;
        
        // Aktualizuj statystyki
        updateStats(data.stats);
        
        // Wy≈õwietl obrazki
        displayImages();
        
        // Ukryj wska≈∫nik ≈Çadowania wiƒôcej
        document.getElementById('loadMoreIndicator').style.display = 'none';
        
        loadingEl.style.display = 'none';
        
        // Je≈õli jest wiƒôcej obrazk√≥w, w≈ÇƒÖcz infinite scroll
        if (data.hasMore) {
          setupInfiniteScroll();
        } else {
          // Usu≈Ñ listener je≈õli nie ma wiƒôcej obrazk√≥w
          window.removeEventListener('scroll', handleScroll);
        }
        
      } catch (error) {
        console.error('Error loading images:', error);
        loadingEl.style.display = 'none';
        errorContainer.innerHTML = `<div class="error"><strong>B≈ÇƒÖd:</strong> ${error.message}</div>`;
        isLoadingMore = false;
        throw error; // Rzuƒá b≈ÇƒÖd ≈ºeby .finally() zadzia≈Ça≈Ç
      }
    }
    
    function filterByDate(images) {
      const dateFrom = document.getElementById('dateFrom').value;
      const dateTo = document.getElementById('dateTo').value;
      
      if (!dateFrom && !dateTo) {
        return images; // Brak filtrowania
      }
      
      // Debug: poka≈º jakie daty sƒÖ u≈ºywane do filtrowania
      console.log(`üîç [FILTER-BY-DATE] Filtering ${images.length} images with dateFrom="${dateFrom}", dateTo="${dateTo}"`);
      
      let filteredCount = 0;
      let rejectedCount = 0;
      const rejectedReasons = {};
      const sampleRejected = []; // Przechowaj przyk≈Çadowe odrzucone obrazy dla debugowania
      
      const filtered = images.filter(image => {
        // Sprawd≈∫ czy uploadedAt istnieje i jest poprawny
        if (!image.uploadedAt) {
          rejectedCount++;
          rejectedReasons['no_date'] = (rejectedReasons['no_date'] || 0) + 1;
          if (rejectedCount <= 5) {
            console.warn('‚ö†Ô∏è [FILTER] Image missing uploadedAt:', image.pathname);
          }
          return false; // Ukryj obrazy bez daty
        }
        
        try {
          const imageDate = new Date(image.uploadedAt);
          
          // Sprawd≈∫ czy data jest poprawna
          if (isNaN(imageDate.getTime())) {
            rejectedCount++;
            rejectedReasons['invalid_date'] = (rejectedReasons['invalid_date'] || 0) + 1;
            if (rejectedCount <= 5) {
              console.warn('‚ö†Ô∏è [FILTER] Invalid date:', image.uploadedAt, image.pathname);
            }
            return false;
          }
          
          // ‚ö†Ô∏è KRYTYCZNE: Por√≥wnuj TYLKO daty (bez czasu) w lokalnej strefie czasowej
          // U≈ºyj lokalnych dat zamiast UTC ≈ºeby uniknƒÖƒá problem√≥w ze strefƒÖ czasowƒÖ
          const imageDateOnly = new Date(imageDate.getFullYear(), imageDate.getMonth(), imageDate.getDate());
          
          if (dateFrom) {
            const fromDate = new Date(dateFrom + 'T00:00:00');
            if (isNaN(fromDate.getTime())) {
              console.error('‚ùå [FILTER] Invalid dateFrom:', dateFrom);
              filteredCount++;
              return true; // Je≈õli data jest niepoprawna, poka≈º obraz
            }
            // Por√≥wnaj tylko daty (bez czasu) w lokalnej strefie czasowej
            const fromDateOnly = new Date(fromDate.getFullYear(), fromDate.getMonth(), fromDate.getDate());
            
            if (imageDateOnly < fromDateOnly) {
              rejectedCount++;
              rejectedReasons['before_from'] = (rejectedReasons['before_from'] || 0) + 1;
              if (rejectedCount <= 10) {
                const imageDateStr = `${imageDateOnly.getFullYear()}-${String(imageDateOnly.getMonth() + 1).padStart(2, '0')}-${String(imageDateOnly.getDate()).padStart(2, '0')}`;
                const fromDateStr = `${fromDateOnly.getFullYear()}-${String(fromDateOnly.getMonth() + 1).padStart(2, '0')}-${String(fromDateOnly.getDate()).padStart(2, '0')}`;
                console.log(`‚ùå [FILTER] Rejected (before fromDate): ${image.pathname}, imageDate=${imageDateStr}, fromDate=${fromDateStr}, uploadedAt="${image.uploadedAt}"`);
                if (rejectedCount <= 5) {
                  sampleRejected.push({
                    pathname: image.pathname,
                    imageDate: imageDateStr,
                    fromDate: fromDateStr,
                    uploadedAt: image.uploadedAt
                  });
                }
              }
              return false;
            }
          }
          
          if (dateTo) {
            const toDate = new Date(dateTo + 'T00:00:00');
            if (isNaN(toDate.getTime())) {
              console.error('‚ùå [FILTER] Invalid dateTo:', dateTo);
              filteredCount++;
              return true; // Je≈õli data jest niepoprawna, poka≈º obraz
            }
            // Por√≥wnaj tylko daty (bez czasu) w lokalnej strefie czasowej
            const toDateOnly = new Date(toDate.getFullYear(), toDate.getMonth(), toDate.getDate());
            
            if (imageDateOnly > toDateOnly) {
              rejectedCount++;
              rejectedReasons['after_to'] = (rejectedReasons['after_to'] || 0) + 1;
              if (rejectedCount <= 5) {
                const imageDateStr = `${imageDateOnly.getFullYear()}-${String(imageDateOnly.getMonth() + 1).padStart(2, '0')}-${String(imageDateOnly.getDate()).padStart(2, '0')}`;
                const toDateStr = `${toDateOnly.getFullYear()}-${String(toDateOnly.getMonth() + 1).padStart(2, '0')}-${String(toDateOnly.getDate()).padStart(2, '0')}`;
                console.log(`‚ùå [FILTER] Rejected (after toDate): ${image.pathname}, imageDate=${imageDateStr}, toDate=${toDateStr}`);
              }
              return false;
            }
          }
          
          filteredCount++;
          return true;
        } catch (error) {
          rejectedCount++;
          rejectedReasons['error'] = (rejectedReasons['error'] || 0) + 1;
          if (rejectedCount <= 5) {
            console.error('‚ùå [FILTER] Error filtering image:', error, image.pathname);
          }
          return false;
        }
      });
      
      // Debug summary
      if (dateFrom || dateTo) {
        console.log(`üîç [FILTER] Date filter summary:`, {
          total: images.length,
          filtered: filtered.length,
          rejected: rejectedCount,
          dateFrom: dateFrom,
          dateTo: dateTo,
          rejectionReasons: rejectedReasons,
          sampleRejected: sampleRejected.slice(0, 5) // Poka≈º pierwsze 5 odrzuconych dla debugowania
        });
        
        // Je≈õli wszystkie obrazy zosta≈Çy odrzucone, poka≈º przyk≈Çadowe daty z obraz√≥w
        if (filtered.length === 0 && images.length > 0) {
          const sampleDates = images.slice(0, 10).map(img => ({
            pathname: img.pathname,
            uploadedAt: img.uploadedAt,
            category: img.category
          }));
          console.warn(`‚ö†Ô∏è [FILTER] All ${images.length} images rejected! Sample dates:`, sampleDates);
        }
      }
      
      return filtered;
    }
    
    function setDateRange(range) {
      const today = new Date();
      const dateFrom = document.getElementById('dateFrom');
      const dateTo = document.getElementById('dateTo');
      
      // Funkcja pomocnicza do formatowania lokalnej daty (nie UTC!)
      const formatLocalDate = (date) => {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
      };
      
      let from, to;
      
      switch(range) {
        case 'today':
          // ‚ö†Ô∏è U≈ºyj lokalnej daty, nie UTC! (toISOString() mo≈ºe zwr√≥ciƒá wczoraj je≈õli jeste≈õ w UTC+)
          const localToday = formatLocalDate(today);
          console.log(`üîç [DATE-RANGE] Setting "dzisiaj" to: ${localToday} (local date, not UTC)`);
          dateFrom.value = localToday;
          dateTo.value = localToday;
          loadImages(true);
          return;
        case 'week':
          from = new Date(today);
          from.setDate(today.getDate() - 7);
          to = new Date(today);
          break;
      }
      
      if (from && to) {
        dateFrom.value = formatLocalDate(from);
        dateTo.value = formatLocalDate(to);
        loadImages(true);
      }
    }
    
    function clearDateRange() {
      document.getElementById('dateFrom').value = '';
      document.getElementById('dateTo').value = '';
      loadImages(true);
    }

    // Domy≈õlny zakres dat: ostatnie N dni (w≈ÇƒÖcznie z dzisiaj), ale tylko je≈õli pola sƒÖ puste
    function setDefaultLastDaysIfEmpty(days) {
      const dateFromEl = document.getElementById('dateFrom');
      const dateToEl = document.getElementById('dateTo');
      if (!dateFromEl || !dateToEl) return;
      
      // Je≈õli user ju≈º ma ustawione daty (albo przeglƒÖdarka je przywr√≥ci≈Ça) - nie nadpisuj
      if (dateFromEl.value || dateToEl.value) return;
      
      const today = new Date();
      const from = new Date(today);
      from.setDate(today.getDate() - (Math.max(1, days) - 1)); // np. 5 dni: dzi≈õ-4
      
      const formatLocalDate = (date) => {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
      };
      
      dateFromEl.value = formatLocalDate(from);
      dateToEl.value = formatLocalDate(today);
      
      console.log(`üîç [DEFAULT-DATE] Ustawiam domy≈õlnie ostatnie ${days} dni: ${dateFromEl.value} ‚Üí ${dateToEl.value}`);
    }
    
    function displayImages() {
      const galleryEl = document.getElementById('gallery');
      galleryEl.innerHTML = '';
      
      // ‚ö†Ô∏è KRYTYCZNE: Najpierw filtruj po kategorii, POTEM po dacie!
      const category = document.getElementById('categoryFilter').value;
      let filteredImages = allImages;
      
      // 1. Filtruj po kategorii NAJPIERW
      if (category !== 'all') {
        const beforeCategoryFilter = filteredImages.length;
        
        // Debug: sprawd≈∫ kategorie przed filtrowaniem
        const categoryCounts = {};
        filteredImages.forEach(img => {
          const cat = img.category || 'NO_CATEGORY';
          categoryCounts[cat] = (categoryCounts[cat] || 0) + 1;
        });
        console.log(`üîç [CATEGORY-FILTER] Category counts before filter:`, categoryCounts);
        
        filteredImages = filteredImages.filter(img => img.category === category);
        console.log(`üîç [DISPLAY] Category filter "${category}": ${beforeCategoryFilter} ‚Üí ${filteredImages.length}`);
      }
      
      // Poka≈º/ukryj filtr produktu gdy kategoria = wygenerowane
      const productTypeFilterGroup = document.getElementById('productTypeFilterGroup');
      if (productTypeFilterGroup) {
        productTypeFilterGroup.style.display = category === 'wygenerowane' ? 'flex' : 'none';
      }
      
      // 1b. Filtruj po productType (tylko dla wygenerowanych)
      const productTypeFilter = document.getElementById('productTypeFilter')?.value;
      if (category === 'wygenerowane' && productTypeFilter) {
        filteredImages = filteredImages.filter(img => img.productType === productTypeFilter);
      }
      
      // 2. Filtruj po datach PO kategorii
      const dateFrom = document.getElementById('dateFrom').value;
      const dateTo = document.getElementById('dateTo').value;
      const beforeDateFilter = filteredImages.length;
      filteredImages = filterByDate(filteredImages);
      
      // 3. SORTOWANIE - upewnij siƒô ≈ºe najnowsze sƒÖ na g√≥rze!
      // API ju≈º sortuje, ale na wszelki wypadek posortuj jeszcze raz po stronie klienta
      const sortBy = document.getElementById('sortBy').value;
      const sortOrder = document.getElementById('sortOrder').value;
      
      if (sortBy === 'date') {
        filteredImages.sort((a, b) => {
          const dateA = new Date(a.uploadedAt || 0).getTime();
          const dateB = new Date(b.uploadedAt || 0).getTime();
          return sortOrder === 'asc' ? dateA - dateB : dateB - dateA; // desc = najnowsze na poczƒÖtku
        });
      } else if (sortBy === 'name') {
        filteredImages.sort((a, b) => {
          const nameA = (a.pathname || '').toLowerCase();
          const nameB = (b.pathname || '').toLowerCase();
          return sortOrder === 'asc' 
            ? nameA.localeCompare(nameB)
            : nameB.localeCompare(nameA);
        });
      }
      
      // Debug logging
      if (dateFrom || dateTo || category !== 'all') {
        console.log('üîç [DISPLAY] Filter summary:', {
          totalAllImages: allImages.length,
          afterCategoryFilter: beforeDateFilter,
          afterDateFilter: filteredImages.length,
          category: category,
          dateFrom: dateFrom,
          dateTo: dateTo,
          sampleFiltered: filteredImages.slice(0, 3).map(img => ({
            pathname: img.pathname,
            uploadedAt: img.uploadedAt,
            category: img.category
          }))
        });
      }
      
      // Aktualizuj licznik w filtrze
      updateFilteredCount();
      
      filteredImages.forEach((image, index) => {
        const card = document.createElement('div');
        card.className = 'image-card';
        card.dataset.index = index;
        
        const isSelected = selectedImages.has(image.url);
        if (isSelected) {
          card.classList.add('selected');
        }
        
        const isJson = image.isJson || image.pathname.toLowerCase().endsWith('.json');
        const fileName = image.pathname.split('/').pop();
        
        if (isJson) {
          // Plik JSON - wy≈õwietl jako tekst
          card.innerHTML = `
            <input type="checkbox" class="checkbox" ${isSelected ? 'checked' : ''} 
                   onchange="toggleSelection('${image.url}', ${index})">
            <div style="
              width: 100%;
              height: 200px;
              background: #f5f5f5;
              display: flex;
              align-items: center;
              justify-content: center;
              border-radius: 8px;
              margin-bottom: 10px;
              cursor: pointer;
              border: 2px solid #ddd;
            " onclick="window.open('${image.url}', '_blank')">
              <div style="text-align: center; color: #666;">
                <div style="font-size: 48px; margin-bottom: 10px;">üìÑ</div>
                <div style="font-size: 12px; font-weight: 600;">Plik JSON</div>
                <div style="font-size: 10px; color: #999; margin-top: 5px;">${(image.size / 1024).toFixed(1)} KB</div>
              </div>
            </div>
            <div class="image-info">
              <span class="category ${image.category}">${image.category}</span>
              <div class="filename">${fileName}</div>
              <div class="date">${new Date(image.uploadedAt).toLocaleString('pl-PL')}</div>
            </div>
          `;
        } else {
          // productType ‚Üí czytelna etykieta (karykatura, kr√≥l, koty, telefon, boho, etc.)
          const productTypeLabels = { caricature: 'Karykatura', king: 'Kr√≥l', queen: 'Kr√≥lowa', cats: 'Koty', phone: 'Telefon', boho: 'Boho', other: 'Inne', spotify: 'Spotify', etui: 'Etui' };
          const safeProductType = typeof image.productType === 'string' && /^[a-z0-9_-]+$/i.test(image.productType) ? image.productType : null;
          const productTypeLabel = safeProductType ? (productTypeLabels[safeProductType] || safeProductType) : null;
          const productTypeHtml = productTypeLabel ? `<span class="product-type">${productTypeLabel}</span>` : '';
          // Obrazek - normalne wy≈õwietlanie z retry logic
          card.innerHTML = `
            <input type="checkbox" class="checkbox" ${isSelected ? 'checked' : ''} 
                   onchange="toggleSelection('${image.url}', ${index})">
            <img src="${image.url}" alt="${image.pathname}" loading="lazy" 
                 onerror="retryImageLoad(this, '${image.url}', 3)"
                 onclick="window.open('${image.url}', '_blank')"
                 style="cursor: pointer;">
            <div class="image-info">
              <span class="category ${image.category}">${image.category}</span>
              ${productTypeHtml}
              <div class="filename">${fileName}</div>
              <div class="date">${new Date(image.uploadedAt).toLocaleString('pl-PL')}</div>
            </div>
          `;
        }
        
        galleryEl.appendChild(card);
      });
    }
    
    function updateStats(stats) {
      document.getElementById('statTotal').textContent = stats.total || 0;
      document.getElementById('statUpload').textContent = stats.upload || 0;
      document.getElementById('statOrders').textContent = stats.orders || 0;
      document.getElementById('statKoszyki').textContent = stats.koszyki || 0;
      document.getElementById('statWygenerowane').textContent = stats.wygenerowane || 0;
      document.getElementById('statStatystyki').textContent = stats.statystyki || 0;
      
      // Aktualizuj licznik w filtrze
      updateFilteredCount();
    }
    
    function updateFilteredCount() {
      const category = document.getElementById('categoryFilter').value;
      let filteredImages = filterByDate(allImages);
      
      if (category !== 'all') {
        filteredImages = filteredImages.filter(img => img.category === category);
      }
      const productTypeFilter = document.getElementById('productTypeFilter')?.value;
      if (category === 'wygenerowane' && productTypeFilter) {
        filteredImages = filteredImages.filter(img => img.productType === productTypeFilter);
      }
      
      document.getElementById('statFiltered').textContent = filteredImages.length;
    }
    
    function toggleSelection(url, index) {
      if (selectedImages.has(url)) {
        selectedImages.delete(url);
      } else {
        selectedImages.add(url);
      }
      updateDeleteButton();
      displayImages();
    }
    
    function selectAll() {
      // Zaznacz tylko widoczne (przefiltrowane) obrazki
      const filteredImages = filterByDate(allImages);
      filteredImages.forEach(img => selectedImages.add(img.url));
      updateDeleteButton();
      displayImages();
    }
    
    function updateDeleteButton() {
      const count = selectedImages.size;
      document.getElementById('selectedCount').textContent = count;
      document.getElementById('deleteBtn').disabled = count === 0;
    }
    
    async function deleteSelected() {
      if (selectedImages.size === 0) return;
      
      if (!confirm(`Czy na pewno chcesz usunƒÖƒá ${selectedImages.size} obrazk√≥w?`)) {
        return;
      }
      
      const urls = Array.from(selectedImages);
      let successCount = 0;
      let errorCount = 0;
      
      for (const url of urls) {
        try {
          const response = await fetch(`${API_BASE}/delete-blob-image`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${AUTH_TOKEN}`
            },
            body: JSON.stringify({ url })
          });
          
          if (response.ok) {
            successCount++;
          } else {
            errorCount++;
          }
        } catch (error) {
          errorCount++;
        }
      }
      
      alert(`Usuniƒôto: ${successCount}, B≈Çƒôdy: ${errorCount}`);
      selectedImages.clear();
      updateDeleteButton();
      loadImages(true);
    }
    
    let isLoadingMore = false;
    let cleanupCancelled = false;
    let cleanupInProgress = false;
    
    function loadMore() {
      if (isLoadingMore || !currentCursor) return;
      
      isLoadingMore = true;
      document.getElementById('loadMoreIndicator').style.display = 'block';
      
      loadImages(false).finally(() => {
        isLoadingMore = false;
      });
    }
    
    // Infinite scroll - automatyczne ≈Çadowanie przy scrollu do do≈Çu
    function setupInfiniteScroll() {
      // Usu≈Ñ poprzednie listenery
      window.removeEventListener('scroll', handleScroll);
      
      // Dodaj nowy listener
      window.addEventListener('scroll', handleScroll, { passive: true });
    }
    
    function handleScroll() {
      // Sprawd≈∫ czy u≈ºytkownik jest blisko do≈Çu strony
      const scrollPosition = window.innerHeight + window.scrollY;
      const documentHeight = document.documentElement.scrollHeight;
      const threshold = 500; // Za≈Çaduj gdy jest 500px od do≈Çu
      
      if (scrollPosition >= documentHeight - threshold && !isLoadingMore && currentCursor) {
        loadMore();
      }
    }
    
    // Retry logic dla obrazk√≥w - rozwiƒÖzuje problem z ≈Çadowaniem
    function retryImageLoad(imgElement, imageUrl, maxRetries) {
      if (!imgElement.dataset.retryCount) {
        imgElement.dataset.retryCount = '0';
      }
      
      const retryCount = parseInt(imgElement.dataset.retryCount, 10);
      
      if (retryCount >= maxRetries) {
        // Po max pr√≥bach - poka≈º placeholder
        imgElement.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2Y1ZjVmNSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMTQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj7imYQgQmzEhCB3Y3R5dGFuaWE8L3RleHQ+PC9zdmc+';
        imgElement.alt = 'B≈ÇƒÖd ≈Çadowania obrazka';
        imgElement.style.cursor = 'default';
        imgElement.onclick = null;
        return;
      }
      
      // Retry z cache busting
      imgElement.dataset.retryCount = (retryCount + 1).toString();
      const retryUrl = imageUrl + (imageUrl.includes('?') ? '&' : '?') + '_retry=' + retryCount + '&_t=' + Date.now();
      
      setTimeout(() => {
        imgElement.src = retryUrl;
      }, 500 * (retryCount + 1)); // Exponential backoff: 500ms, 1000ms, 1500ms
    }
    
    // Event listeners
    document.getElementById('categoryFilter').addEventListener('change', () => {
      updateFilteredCount();
      displayImages();
    });
    const productTypeFilterEl = document.getElementById('productTypeFilter');
    if (productTypeFilterEl) {
      productTypeFilterEl.addEventListener('change', () => {
        updateFilteredCount();
        displayImages();
      });
    }
    document.getElementById('sortBy').addEventListener('change', () => loadImages(true));
    document.getElementById('sortOrder').addEventListener('change', () => loadImages(true));
    document.getElementById('dateFrom').addEventListener('change', () => {
      updateFilteredCount();
      displayImages();
    });
    document.getElementById('dateTo').addEventListener('change', () => {
      updateFilteredCount();
      displayImages();
    });
    
    // Login jest sprawdzany w checkLogin() przy DOMContentLoaded

    async function runAutoCleanupOldFiles() {
      if (!AUTH_TOKEN) {
        alert('Brak tokena autoryzacji');
        return;
      }
      if (cleanupInProgress) {
        return;
      }
      
      cleanupCancelled = false;
      cleanupInProgress = true;
      
      const cleanupBtn = document.getElementById('cleanupBtn');
      const cleanupStatus = document.getElementById('cleanupStatus');
      const cleanupStatusText = document.getElementById('cleanupStatusText');
      cleanupBtn.disabled = true;
      cleanupStatus.classList.remove('hidden');
      
      const MAX_ROUNDS = 25; // 25 * 300 = 7500 plik√≥w max na jedno klikniƒôcie
      const BATCH_SIZE = 300; // endpoint ma hard cap 300
      
      let totalDeleted = 0;
      let lastDeleted = 0;
      
      try {
        for (let round = 1; round <= MAX_ROUNDS; round++) {
          if (cleanupCancelled) {
            cleanupStatusText.textContent = `‚èπÔ∏è Przerwano. Usuniƒôto ≈ÇƒÖcznie: ${totalDeleted}`;
            break;
          }
          
          cleanupStatusText.textContent = `üßπ Czyszczenie starych plik√≥w (>14 dni)‚Ä¶ tura ${round}/${MAX_ROUNDS} (≈ÇƒÖcznie usuniƒôto: ${totalDeleted})`;
          
          const url = `${API_BASE}/cleanup-old-blobs?dryRun=false&maxDelete=${BATCH_SIZE}`;
          const resp = await fetch(url, {
            headers: { 'Authorization': `Bearer ${AUTH_TOKEN}` }
          });
          
          if (!resp.ok) {
            const text = await resp.text().catch(() => '');
            throw new Error(`HTTP ${resp.status}: ${text || resp.statusText}`);
          }
          
          const data = await resp.json();
          if (!data || !data.success) {
            throw new Error(data?.error || 'Cleanup failed');
          }
          
          lastDeleted = data?.stats?.deleted || 0;
          totalDeleted += lastDeleted;
          
          // Je≈õli nic ju≈º nie usuwa, ko≈Ñczymy
          if (lastDeleted === 0) {
            cleanupStatusText.textContent = `‚úÖ Gotowe. Brak kolejnych starych plik√≥w do usuniƒôcia. Usuniƒôto ≈ÇƒÖcznie: ${totalDeleted}`;
            break;
          }
          
          // Ma≈Ça przerwa, ≈ºeby nie dobijaƒá API
          await new Promise(r => setTimeout(r, 400));
        }
      } catch (e) {
        console.error('‚ùå [CLEANUP] Error:', e);
        cleanupStatusText.textContent = `‚ùå B≈ÇƒÖd czyszczenia: ${e.message}`;
      } finally {
        cleanupInProgress = false;
        cleanupBtn.disabled = false;
        
        // Od≈õwie≈º listƒô obrazk√≥w po sprzƒÖtaniu (≈ºeby pokazaƒá nowsze)
        try {
          await loadImages(true);
        } catch (_) {}
      }
    }
    
    function cancelAutoCleanup() {
      cleanupCancelled = true;
    }
  </script>
</body>
</html>
